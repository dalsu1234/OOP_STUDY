/*

POD 보충설명

클래스와 구조체와의 차이에서 생성자의 존재유무때문에
클래스는 POD에 해당되지 않고
구조체는 POD에 해당된다고 했는데

클래스에 생성자가 없고 함수가 존재한다면 
클래스는 POD에 해당하는가?

간단하게 설명하자면
클래스에 크기를 결정하는건 멤버변수의 타입과 갯수이지
함수와는 상관이 없다
이유는 함수는 메모리에 다른곳에 올라간다

즉 클래스를 인스턴스화 하면
인스턴스는 메모리에 STACK에 올라가고
함수들은 CODE라는 곳에 올라간다

즉 클래스와 클래스 내에 함수들이 메모리 영역에 올라가는 장소가 다르다

스택메모리에 올라가는것 멤버변수

다시 정리하면
생성자는 가공이 일어날수있기때문에
생성자라는것이 존재하기때문에 POD가 아니게된다

함수는 코드에 올라가기때문에 POD랑 상관이 없다

------------------------------------------------------------------


# 멤버초기화식

예제>>

#############################################
class ClassA
{
	int mID;
	int mExp;
	
public:
	Quest(int id, int exp) : mExp {exp}, mID{id}
};
#############################################
이렇게 초기화 할때
누가 먼저 초기화가 될까

초기화식에서 mExp가 먼저 앞에 있다고 해도
멤버변수 순서로 초기화가 된다
즉 mID가 먼저 초기화 된다


------------------------------------------------------------------


delegating constructor
# 대리생성자

예제>>

############################################################################

class Quest
{
private:
	int mID;
	int mExp;

public:
	Quest(int id, int exp) : mID{1}, mExp{1}
	{
		// 1. 기본 작업
	}

	Quest(std::string excel) : mID{ 2 }, mExp{2}
	{
		// 1. 기본 작업 << 중복
		Quest(); 
		// 기본 작업 중복이 되기때문에 코드를 이렇게 작성해서 해결하려고 하지만
		// 이코드가 의미하는건 함수를 부르는것이 아니다
		// int(); 와 같은 느낌이다 즉 아무런 의미가없다
		// 무슨 말이냐하면 객체를 만들지만 붙여줄 이름이 없다
		// q1이라는 이름은 Quest(std::string excel)에 붙여지는것이지 
		// Quest(); 은 이름이 없이 버려지는 객체다
		// int = {};과 같은 느낌
		// 생성자는 함수와 다르다
		// 이래서 대리생성자가 필요하다


		// 2. 엑셀 작업
	}

	void Print()
	{
		std::cout << "ID : " << mID << ", Exp : " << mExp << std::endl;
	}
};

int main()
{
	Quest q1("1.xlsx");
	q1.Print();
}


출력은  2, 2 가 나온다

############################################################################

# 대리생성자로 해결법

Quest(int id, int exp) : mID{1}, mExp{1}
{
	// 1. 기본 작업
}

Quest(std::string excel) : Quest() << 대리생성자 
{
	// 2.
}

이러면 1 기본작업을 하는 생성자가 생성되고
	   2 작업으로 넘어간다


#######################################################################

 #대리생성자

멤버 초기화식 뒤에 다른 생성자를 불러 줄 수 있다.

 단점
 - 대리생성자를 쓸경우 멤버초기화식과 혼용해서 쓸수없다
   
   Quest(std::string excel) : Quest(), mID{1}
   컴파일 오류
   // 귀찮지만 이런식으로 써야한다
   Quest(std::string excel) : Quest()
   {
		mID = 1;
   }

-----------------------------------------------------------------------

!생성자는 객체를 생성하는 기능이지 함수가 아니다

-----------------------------------------------------------------------

Destructor
# 소멸자

~Quest()


소멸자는 오버로딩에 개념이 없다

소멸자가 사용되는 시점은 


예제>>
####################################################################################

class MyArray
{

private:
	int mLength;
	int* mArray;

public:
	MyArray(int length) : mLength{ length }
	{
		mArray = new int[length] {};
	}

};

int main()
{
	MyArray array{ 20 };

}

####################################################################################


스택에
MyArray 타입에 array 객체가 만들어 진후
멤버변수 mLength 를 만들고

포인터 mArray를 만든후
mArray는 포인터니깐 Heap에 int 20칸 짜리로
만들어서 포인터로 연결

그리고
main이 끝나는 스코프에서 스택에 만들어진 mArray 객체가
소멸자에 의해 사라지는데
문제는 여기서부터 생긴다
Heap에 남겨진 동적배열은? 삭제를 안하고 스택에 있는 mArray객체가
먼저 사라져버려서 삭제할 방법이 없어진다 메모리 누수(메모리 릭)

#해결법

소멸자로 해결한다

####################################################################################

~MyArray()
{
	delete[] mArray;
	mArray = nullptr;
}

####################################################################################

! 반드시 동적배열을 만든다면 소멸자를 이런식으로 만들어야한다

##########################################################################


연습문제

1. 주어진 문자열 리터럴로 생성이 가능한 String 클래스를 설계해 봅시다.
문자열 리터럴로 동적 생성
			 String s1{ "Hello World"  };
문자열 출력
			s1.Print();

			> Hello World


<Challenge>
기존에 제작한 동적 스택 & 동적 큐를 클래스 버전으로 만들어 봅시다.
구조체버전과 클래스버전의 차이 !!!!
Procedural Programming vs Object Oriented Programming
소감문!

*/

