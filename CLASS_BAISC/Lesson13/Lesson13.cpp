/*

Typecast

class Character{};   // 기반클래스

class Warrior : public Character{}; // 파생클래스


Character is-a Warrior
캐릭터는 워리어다      이말은 맞을수도 있고 틀릴수도있는 명제

Warrior is-a Character
워리어는 캐릭터다      맞는 명제



up-cast			vs			down-cast

자식 -> 부모				부모 -> 자식

안전한변환					체크해야한다(런타임때 체크해봐야 알수있음)

암시적변환					명시적변환



up-cast예제>>
##########################################
Character* pHero = new Warrior();
여기에는 이미 암시적 형변환이 사용되고있다

Warrior타입이 만들어지고 돌아올텐데
만들어진 Warrior를 Character*로 형변환이
이미 암시적으로 사용되고있는거다
이게 가능한 이유가 up-cast라 가능
파생클래스에서 기반클래스로는 안전한변환이라
암시적으로 사용이 가능한것!!
##########################################

down-cast예제
##########################################
Character* pHero = new Warrior();

를

(Warrior*)pHero 로 명시적형변환

pHero는 기반클래스 타입이니깐
파생클래스로 형변환 하려면 저렇게 명시적으로 형변환을 하고
런타임때 체크를 한다
하지만 좀더 안전한 방법이 존재하는데 그건
##########################################


#down - cast의 형변환의 안전한 타입

#############################################

static_cast<변환을 원하는 타입>( 표현식 );  

dynamic_cast<변환을 원하는 타입>( 표현식 );
	- 런타임때 타입에 대해 정보가 추가적으로 필요하다 : RTTI 라고 한다

#############################################

static_cast 의 뜻은
정적으로 캐스트한다
즉 컴파일타임으로 캐스트 한다

런타임을 컴파일로 캐스팅 한다라고 생각하면 되나?


예제>>
##############################################
float x = 10.5f;
int y = static_cast<int>(x);

##############################################

##동적 캐스팅
오늘의 핵심이야기


예제>>
##############################################
	
	
	((Warrior*)pHero)->DoubleSlash();
	동적캐스팅으로 바꿔보자

	dynamic_cast<Warrior*>(pHero)->DoubleSlash();
	이렇게 바꿀수도있지만 이건 위 식과 같이 안전한 표현이 아니다

	안전한표현을 하고싶다면?
	###################################################

	Warrior* pWarrior = dynamic_cast<Warrior*>(pHero);

	if (pWarrior == nullptr)
	{
		std::cout << "Error" << std::endl;
	}
	else
	{
		pWarrior->DoubleSlash();
	}

	###################################################
	이렇게 표현하는게 매우 안전하다


##############################################

그외에 몇가지가 더있는데

reinterpret_cast<타입>(표현식);
	- 다 바꿔주는 캐스트
	- 완전히 재해석한다
	- 안전을 보장하진않는다

const_cast<타입>(표현식)
	- const타입을 제거하거나 다시 설정할수도 있는 캐스팅

차피 이 두가지는 잘 안씀


#############################################

사용처 

다이나믹캐스트
런타임에 타입을 체크할수있는 캐스트

어떤 타입인지 불확실하거나
좀더 안정적인 변환이 필요하다면 다이나믹캐스트를 사용한다

상속과 관련된 다형성의 포인터를 받을 때
체크를 해서 살펴보고 안정적으로 형변환을 할때


OOP의 다형성은
실제로 어떤타입인지 런타임때 알수있으니깐
###############################################

#추상클래스

#순수가상함수

기반클래스에서 가상함수들은 선언만 필요하고 
정의는 필요하지않는경우가 있다

그럴때는 기반클래스 헤더파일에서

virtual <타입> <함수명()> {} = 0;

이런식으로 선언만 해줄수있다

이게 순수가상함수

실체가 없는 함수다

그냥 virtual만 쓴다면 실체는 존재하지만 이런식으로 쓴다면
실체가 없는 함수로 존재


하지만 이대로 쓴다면 추상클래스를 인스턴스화 할수없다 라고 컴파일 에러가 생긴다

#############################################################################
#추상클래스

	- 실제로 존재하지않는 함수가 있어야한다
	>> 순수가상함수를 가진 클래스를 추상클래스라 한다

	- 인스턴스화가 불가능하다

	- 기반 클래스로만 사용될수있다

	- 파생 클래스에서 모든 순수 가상함수를 재정의(오버라이딩) 해야함




예제
##########################################################################


class Character
{
public:
	virtual void Attack() cosnt = 0;
	virtual void Dead() const = 0; // 가상함수들
}

class Warrior : public Character
{
public:
	void Attack() override;
	void Dead() override;      // 이렇게 파생클래스에서 선언을 해줘야함
}

기반클래스의 가상함수들을 빠짐없이 
파생클래스에서 선언을 해줘야한다


##########################################################################

#interface
	모든 멤버함수가 순수 가상함수로만 이뤄진 추상클래스

	추상클래스는 한개이상의 가상함수만 있어도 추상클래스라하지만
	인터페이스튼 모든 멤버함수가 가상함수라해야한다

##########################################################################

---------------------------------------------------------------------------


##멤버함수의 포인터

int Sigma(int (*f)(intx),int m, int n)
{
	int sum{};
	for(int i = m; i <= n; ++i)
	{
		// 대충 계산식	
	}
}

int FuncA(int x)
{
	return x;
}

int FuncB(int x)
{
	return x*x;
}
int main()
{
	Sigma(Func,3,3);
	// 머 이런식으로 사용하게끔 할수있게
}

int (*f)(intx) // 멤버함수




#함수포인터

int (*f)(int x)

using f = int (*)(int x);


# 멤버함수의 포인터

######################################################
예제

class MyFunction
{
public:
	int NormalFunc(int x)
	{
		return x;
	}

	int SquareFunc(int x)
	{
		return x*x;
	}
};

using FunPtr1 = int (*) (int);				// 함수포인터
using FunPtr2 = int (MyFunction::*) (int);	// 멤버함수의 포인터

int Sigma(FunPtr2 f, int m , int n)
{
	int sum{};
	for()
	{
		sum += f(i);
	}
	return sum;
}

int main()
{
	std::cout << Sigma(MyFunction::NomalFunc, 1, 10)<< std::endl;
	std::cout << Sigma(MyFunction::SquareFunc, 1, 10)<< std::endl; 
}


기본적으로 멤버함수들은 인스턴스가 없으면 사용이 불가능하다
그래서 그냥 멤버함수들을 함수포인터로 쓸려면
쉽게할수있는 방법이 static으로 멤버함수들을 선언하면된다

static으로 선언하면 그때부터는 멤버함수들이 인스턴스것이 아닌
클래스에 것이 되기때문에 가능하다

하지만 단점이 존재
클래스안에 있는 멤버변수들을 사용할수가없다
클래스것이라 모든 멤버변수에 접근에 제약이 생김


그럼 해결책



using FunPtr2 = int (MyFunction::*) (int);	// 멤버함수의 포인터의 표현식


int Sigma(MyFunction& instance, FunPtr2 f, int m , int n)
{
	int sum{};
	for()
	{
		sum += (instane.*f)(i); // f라는 함수포인터를 역참조
	}

	//(instane.*f)(i) 이표현식은
	인스턴스에 있는 멤버함수포인터에 접근
	그리고 매개변수 포인터 함수를 역참조해야하기때문에
	*f를 하는데
	그냥 괄호 없이 사용한다면 의미가 달라지기때문에
	
	(intstanc.*f)(i); 로 사용하면된다
	인스턴스안에 있는 함수포인터를 역참조

	
	return sum;
}
int main
{
	MyFunction mf;
	
	std::cout << Sigma(mf, &MyFunction::NomalFunc, 1, 10)<< std::endl;
	std::cout << Sigma(mf, &MyFunction::SquareFunc, 1, 10)<< std::endl;
	// 일단 인스턴스가 필요하기때문에 Sigma함수에 매개변수에
	인스턴스를 매개변수로 사용한다
	MyFunction::SquareFunc 이렇게 사용하면 클래스함수에 접근한다는 의미이기
	떄문에 컴파일 오류가 생긴다

	&MyFunction::NomalFunc 이렇게 써야지 함수포인터에 접근한다는 의미가 된다	
}

후... 어렵다

##########################################################################


정리


		함수포인터(정적멤버함수)		vs		멤버함수의 포인터
		
표현식	ret-type (*)(param-lis)					ret-type (class-name::*)(param-lis)

예제	uisng fptr = int (*)(int x)				uing fptr = int (MyClass::*)(int x)

사용	fptr(3)									(instance.*fptr)(3);


비정적이면 반드시 인스턴스가 필요하다

##########################################################################

-----------------------------------------------------------------------------





*/