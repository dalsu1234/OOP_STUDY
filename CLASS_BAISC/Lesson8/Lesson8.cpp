/*





++ : 단항 연산자 오버로딩




일반함수 형태
	operator ++(매개변수);

멤버 함수 형태
	operator ++(); 

	예제>>
	전위 증가 연산자
########################################################################

Point2D operator++() // 리턴값에 타입주의
{
	++mX;
	++mY;
	return *this; // this는 포인터 이다 
	//그래서 *this의 형태가 되는것 포인터의 역참조
}
반환값이 포인터가 아닌것은 
예로
++x를 써야하면
x가 포인터의 형태여야한다

########################################################################

참조형태

Point2D& operator++() // Point2D* 로 쓰지않는 이유는
{					  // 받아들이는 객체가 반드시 포인터 타입이여야하는 제한적이기때문에
	++mX;			  // Point2D& 로 써준다 되돌려줄때도 참조로 쓸수있으니깐
	++mY;			  // 하지만 무명객체가 생길수도 있다 ex >> ++(++x); 혹은 ++(x + y);
	return *this;     // 혹은 우측값참조형태로 쓸려면 const를 붙여준다 
}


그럼 최종적으로 이런식으로 쓰면 된다

const Point2D& operator++() 
{
	++mX;
	++mY;
	return *this;
}

########################################################################

#후위 증가 연산자

########################################################################

const Point2D& operator++(int) // 여기서 int는 의미없다 전위증가연산자와 구분할수있게만 하려고 문법이 이런식으로 만들어진다
{
	Point2D temp(mX, mY); // 반환후 증가이기때문에 현재값을 임시값으로 저장후 반환
	
	++(*this); // ++ 연산자를 이미 만든걸 여기서 사용해서 간결하게 작성
	
	return temp;
}

########################################################################

----------------------------------------------------------------------------




#배열[] 연산자 오버로딩 - 이항 연산자
	



	일반 함수 형태
		operator[] (lhs, index);

	멤버 함수 형태
		operator[] (index);



########################################################################
class MyArray
{
private:
	int mArray[10];

public:
	MyArray() : mArray{}
	{
	}

	int Get(int index)
	{
		return mArray[index];
	}

	void Set(int index, int value)
	{
		mArray[index] = value;
	}

	int operator[](int index) // 배열 연산자 오버로딩
	{
		return mArray[index];
	}
};

int main()
{
	MyArray array1;

	std::cout << array1.Get(0) << std::endl;
	//이걸
	std::cout << array1[0] << std::endl;
	//이렇게 사용할수있게 된다

	array1.Set(0,1);
	array1[0] = 1;// 컴파일 오류
	// 대입이 불가능함
	// 이유는 ?  array1[0] 은 반환값이 그냥 int형이라서
	// 즉 array1[0] 는 함수 
	// 반환값으로 치환된다
	// 즉 함수의 반환값에 대입하는꼴이다
	// 0 = 1; 이런 형태 // 대입이 가능하려면 왼쪽이 L-value가 되어야한다 하지만 지금은 R - value
	// 해결법?

}
########################################################################

해결법
int& operator[](int index) // 반환 타입을 참조타입으로
{
	return mArray[index];
}

// array1[0]의 주소값을 참조하고 반환하는것이기때문에 이제 가능하다

########################################################################





# 형변환 연산자 오버로딩




	일반함수 형태
		operator 타입(매개변수);

	멤버 함수 형태
		operator 타입();

형변환연산자는 반환타입이 없다

예제
########################################################################
class Point2D
{
	int mX;
	int mY;

public:
	Point2D(int x, int y) : mX{ x }, mY{y}
	{
	}

	operator const float();
	{
		return sqrt(mX * mX + mY * mY);
	}

};

int main()
{
	Point2D pt1{ 2,3 };

	float distance = pt1;
}
########################################################################

-----------------------------------------------------------------



#함수 호출 연산자

함수를 오브젝트처럼 사용한다해서

펑터라고 부른다
function + object = funtor


########################################################################

class Point2D
{
	int mX;
	int mY;

public:
	Point2D(int x, int y) : mX{ x }, mY{y}
	{
	}

	void operator() () // 매개변수 추가할수도 있다
	{
		mX = 0;
		mY = 0;
	}

};

int main()
{
	Point2D pt1{ 2,3 };

	pt1(); // 함수 호출 연산자  // 함수호출과 같아보이지만 이건 함수 호출 연산자이다
}

########################################################################


# 스트림 연산자 오버로딩 <<, >>  
이항연산자

	일반 함수
		operator << (lhs, rhs);
		operator >> (lhs, rhs);

	멤버 함수
		멤버 함수형태를 만들수 없다
		이유는
		std::cout 이 클래스 자체가 변경이 불가능한 형태라

		예제>>
########################################################################

class Point2D
{
	int mX;
	int mY;

public:
	Point2D(int x, int y) : mX{ x }, mY{y}
	{
	}

	friend std::ostream& operator << (std::ostream& os, const Point2D& pt);

};

std::ostream& operator << (std::ostream& os , const Point2D& pt)
{
	os << "(" << pt.mX << ", " << pt.mY << std::endl;
	return os;
}
// 매개변수 std::ostream os 때문에오류가생긴다
// 이유는? 외부 전역 함수라서 새로 생성할수없게 되어있다
// 그래서 참조 형태로 사용해야한다
// 마찬가지로 반환값도 참조로 해야한다

int main()
{
	Point2D pt1{ 2,3 };

	std::cout << pt1; // 스트림 연산자
}






########################################################################


정리


연산자 오버로딩

1. 가능하다면 멤버 함수 형태로 : friend를 사용하지않고 쓸수있기때문에

2. 전역함수 - 좌측피연산자가 우리가 만든 클래스가 아닌경우는 전역함수로 사용
	
	전역함수형태로 만들때
	-a. Getter / Setter  를 먼저 고려하고
	-b. friend           를 최후로 생각




########################################################################


				멤버 함수								전역 함수

단항 연산자		ret-Type operator op()					ret-Type operator op(매개변수)

이항 연산자		ret-Type operator op(매개변수)			ret-Type operator op(매개변수1, 매개변수2)

변환 연산자		operator 타입()							operator 타입(매개변수)

스트림 연산자					friend ret-type operator << (매개변수)


########################################################################







*/

